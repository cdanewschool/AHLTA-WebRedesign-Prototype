

/**
 * component level object encapsulating the controls for the search module.
 * the search module is composed of two panes, one to get a list of patiens
 * and one to display the list of patients.  the first pain has handlers 
 * for composing query strings for submission to the server and several
 * uri's to address, and the other pain has handlers for selecting a
 * patient from the returned list.
 */
var SearchCtl = {
	
	/**
	 * the patient list must remember who was last selected in order to set
	 * that patient as the current patient if the OK button is pressed
	 * this is the dom level element not an id to the element
	 */
	_tableCtl: null
	
	, forPopup: false

	/**
	 * modifies the state of the current patient dom level element, located in the 
	 * root node of the selected patient wireframe bar, patient id attribute.  this will 
	 * trigger an observable event, the exact type of which is browser implementation 
	 * dependent either w3c or Microsoft.  
	 * @param p_id the new current patient id
	 * @return void
	 * @private
	 * @calls none
	 * @calledby dblClick, lastSelected
	 * 
	 */
	, updateCurPatient : function (p_id){
		try {
			document.getElementById('current_patient').setAttribute( 'patient_id' , p_id );
		} catch (ex) {
			alert('could not set id for current patient:: ' + ex.message);	
			throw(ex);
		}
	} 

	, initContent: function(e, p_id) {
		this._tableCtl = new TableCtl();
	} 

	
	/**
	 * Respond to the cancel button on the form by clearing the internal state of the 
	 * selected patient
	 * @param e the event as returned by the browser
	 * @return void
	 * @calls none
	 * @calledby the front end html mark-up
	 */
	, cancelLast: function (e) {
		this._tableCtl.cancelLast();
		if (! this.forPopup || false == this.forPopup ) {
			document.getElementById('current_patient').setAttribute( 'patient_id' , '' );
		}
	} 

	/**
	 * bound to the list of patients returned from a search, if the user double
	 * clicks a patient, that patient becomes the Currently selected patient
	 * @param e the double click event as generated by the browser
	 * @param p_id the id of the currently selected patient
	 * @return false to stop event bubble
	 * @public
	 * @calls this.updateCurPatient
	 * @calledby frontend table row element as inline text double click handler
	 */
	, dblClick: function(e, p_id ){
		try {
			for (var i = 0; i < this.timed.length; i++) {
				clearTimeout(this.timed[i]);
			}
			this.timed = new Array();
			this._tableCtl.selected(p_id);
			this.lastSelected(e);
		} catch (ex) {
			alert('double click err::' + ex.message);
		}
		return (false);
	} 
	
	, timed : new Array()
	
	/**
	 * respond to a single click to the list of patients returned by a search
	 * when a single click occurs, the row changes color and the patient's id is 
	 * stored here as last selected unless if this WAS the last selected.  in that 
	 * the single click acts like a toggle, first on and now off.
	 * @param e the single click event as created by the browser
	 * @param p_id the id of the patient represented by the row of the search 
	 * results table
	 * @return false to stop the event bubble
	 * @calls none
	 * @calledby the front end as inline text
	 */
	//SearchCtl
	//setTimeout('doTab("tabA")', '500');
	, click: function(e, p_id ){
		this.timed[this.timed.length] = setTimeout('SearchCtl._doClix('+ p_id + ')' , 450); 
	}
	
	, _doClix : function(p_id) {
		try {
			this._tableCtl.selected(p_id, true);
			
		} catch (ex) {
			alert(' search cleick err::' + ex.message);
		}
	}

	/**
	 * responds to the OK button on the list of patients returned by search. 
	 * when the user presses OK, the last selected patient becomes the 
	 * currently selected patient at an application level.  single click plus
	 * the OK button has the same effect as double clicking a row
	 * @param e the browser level event
	 * @return false to stop the bubble
	 * @public
	 * @calls this.updateCurPatient
	 * @calledby html front end markup inline text
	 */
	, lastSelected: function(e) {
		try {
			var selectedTr = this._tableCtl.getLastSelected();
//			alert('last selt = ' + selectedTr);
			if (null != selectedTr) {
				if (! this.forPopup || false == this.forPopup ) {
					this.updateCurPatient(selectedTr.id);
				} else {
					this.popupFiller(selectedTr.id);
//					doGet('spring/appointments?kind=add&patient_id='+ selectedTr.id, apptActions.openAddSched);
				}
			}
			return (false);
			/**	if (! this.forPopup || false == this.forPopup ) { this.updateCurPatient(p_id); } else { var lastSel = this._tableCtl.getLastSelected(); if (null != lastSel) doGet('spring/appointments?kind=add&patient_id='+ lastSel.id, apptActions.openAddSched);} */
		} catch (ex) {
			alert('err lastSelected:: ' + ex.message);
			throw(ex);
		}
	} 

	/*	dblClick: function(e, p_id ){ 
			this._tableCtl.selected(p_id);
			if (! this.forPopup || false == this.forPopup ) {
				this.updateCurPatient(p_id);
			} else {
				var lastSel = this._tableCtl.getLastSelected();
				if (null != lastSel) {
					doGet('spring/appointments?kind=add&patient_id='+ lastSel.id, apptActions.openAddSched);
				}
			} 
		} catch (ex) {  */
	
	
	// stub it
	, popupFiller: function(p_patientId) {
		alert('SearchCtl.popupFiller not initialized');
	}
	/**
	 * bound to the "clear" button in the markup, sets up an empty table for 
	 * search results
	 * @param e the button press event as generated by the browser
	 * @param p_resContainer the search results table 
	 * encompasing element
	 * @returns true to continue bubble
	 * @calls none
	 * @calledby the frontend as inline test handleing the onclick event
	 */
	, clearIt: function (e, p_resContainer) {
		try {
			this._tableCtl.cancelLast();
			if (! this.forPopup || false == this.forPopup) {
				$('current_patient').setAttribute( 'patient_id' , '' );
				
			}
			this._tableCtl = new TableCtl();
			$(p_resContainer).innerHTML =
				'<table summary="Listing of results from Patient Lookup" id="foo"><thead ><tr><th class="twoCent" id="patientName">Patient Name</th><th class="twoCent" id="ssn">SSN</th><th class="twoCent" id="FMP-SponsorSSN">FMP/Sponsor SSN</th><th class="twoCent" id="dob">DOB</th><th class="twoCent" id="sex">Sex</th><th class="twoCent" id="homePhone">Home Phone</th><th class="twoCent" id="workPhone">Work Phone</th><th class="twoCent" id="address">Address</th></tr></thead></table>';
			$('nbrResults').innerHTML = '';
			return (true);
		} catch (ex) {
			alert('clearit error:: ' + ex.message);
			throw(ex);
		}
	} ,

	/**
	 * bound to the patient details button in the search markup.
	 * conducts an ajax request and receives the patient details table
	 * markup from the server.  this markup is html.  the html must 
	 * also be parsed as xml in order to count the number of results
	 * @param e the event for onclick as passed from the browser
	 * @param p_resContainer element to which the results
	 * will be injected via innerhtml
	 * @return false stop the bubble
	 * @calls parsed.loadXML
	 * @calledby inline event handler in the markup for patient details
	 */
	patientDetails: function (e, p_resContainer) {
		try {
			doGet('spring/search?kind=detailed' , this._doAjaxResp);
			return (false);
		} catch (ex) {
			throw(ex);
		}
	} ,
	
	/**
	 * bound to the all patients button in the search markup.
	 * conducts an ajax request and receives the all patients table
	 * markup from the server.  this markup is html.  the html must 
	 * also be parsed as xml in order to count the number of results
	 * @param e the event for onclick as passed from the browser
	 * @param p_resContainer element to which the results
	 * will be injected via innerhtml
	 * @return false stop the bubble
	 * @calls parsed.loadXML
	 * @calledby inline event handler in the markup for patient details
	 */
	allPatients: function (e, p_resContainer) {
		try {
			doGet('spring/search?kind=allPatients' , this._doAjaxResp);
			return (false);
		} catch (ex) {
			throw(ex);
		}
	} ,
	
	/**
	 * the form is valid if it has a last name, and ssn or a sponsor ssn
	 */
	validateForm: function (){
		try {
			return this.checkElt('lastName') 
			|| ( this.checkElt('ssnFirst') && this.checkElt('ssnMiddle') && this.checkElt('ssnLast') )
			|| ( this.checkElt('sponsorSsnFirst') && this.checkElt('sponsorSsnMiddle') && this.checkElt('sponsorSsnLast') );
		} catch (ex) {
			alert('validation err::' + ex.message);
		}
	} ,

	/**
	 * check is the input has a value with a length greater than 0
	 * @privte
	 * @type boolean
	 * @calledBy validateForm
	 */
	checkElt: function(p_id) {
		var elt = $(p_id);
		if (elt && elt.value && (0 < elt.value.length)) {
			return true;
		} else {
			return false;
		}
	} 

	, _doAjaxResp: function (p_fromServer) {
		this._tableCtl = new TableCtl();
		$('searchResContnr').innerHTML = p_fromServer;
		$('nbrResults').innerHTML = countTbodyRows(p_fromServer);
	
	}
	
	/**
	 * this is the central control for the search module and is bound to the 
	 * Find button in the search markup. THis one must constructs a query string and
	 * traverses that section of the code here in this object.  this function conducts 
	 * an ajax request and receives the results table as markup from the server.  this 
	 * markup is html. The html must be parsed as xml in order to count the number of 
	 * results.
	 * @param e the event for onclick as passed from the browser
	 * @param p_formId
	 * @param p_resContainer element to which the results
	 * will be injected via innerhtml
	 * @return false stop the bubble
	 * @calls parsed.loadXML, this.searchQuery
	 * @calledby inline event handler in the markup for patient details
	 */
	, searchFind: function (e, p_formId, p_resContainer) {
		try {
			var thisForm = $(p_formId);
			var queryStr = 'kind=search&' + FormCtl.buildQueryStr(thisForm); 
			var okToGo = this.validateForm();
			if (! okToGo) {
				alert('Last name, SSN, or Sponsor SSN Required');
				return (false);
			}
			doGet('spring/search?' + queryStr, this._doAjaxResp);
			return (false);
		} catch (ex) {
			throw(ex);
		}
	} 

	
	
}


