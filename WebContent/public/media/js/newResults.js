
/**
 * public facing component to which page controls address.  Front end code for the New Results
 * can call these methods which will then set up the internal state of the page  
 */
var newResults = {
		/**
		 * 
		 */
	_tableCtl : null ,
		           
		/**
		 * the is the id of the DOM level parent node for the New Results markup
		 */
	CONTAINER : 'newResultsContainer'
		

		/**
		 * these are all the button.  always turn off all and then selectively restore
		 */
	, _disableButtons : [ 'reviewedAction', 'signRemoveAction'
	                      , 'undoRemoveAction', 'forwardAction', 'moveToNewAction'
	                      , 'signRemoveAction', 'forwardAction', 'moveToNewAction']
		          			
	                      /**
	                       * these are the buttons that are available in the New tab
	                       */
	, _newButtons : ['saveAction', 'reviewedAction'
	                 , 'signRemoveAction', 'forwardAction']

	             	/**
	             	 * these are the buttons that are available in the Saved tab
	             	 */
	, _savedButtons : [ 'signRemoveAction', 'forwardAction',
	                    'moveToNewAction' ]
	/**
	 * keep track of which is the active tab
	 */	          			 			
	, _curTab : null
	

	/**
	 * forward the result by updating the server and refreshing
	 */
	, forwardDo: function(e){
		var providerNcid = $('sel_prov').value;
		if (null == providerNcid) {
			alert('djdk');
		}
		if (this._tableCtl && (null != this._tableCtl.getLastSelected()) ) {
			var testTr = this._tableCtl.getLastSelected();
			doGet('spring/results_new?kind=forwardDo&providerNcid=' 
				+ providerNcid + '&testId=' + testTr.id
				, this._forwardDoHndlr );
			var tds = testTr.getElementsByTagName('td')
			for (var i = 0; i < tds.length; i++ ) {
				if ('status' === tds[i].getAttribute('headers')) {
					tds[i].innerHTML = 'Forwarded' ;
					break;
				}
			}
		}
		return (false);
	}
	
	/**
	 * callback to seetting the foraward confirmation popup 
	 */
	, _forwardDoHndlr: function(p_serverData) {
		try {
			popup.fill(p_serverData, 'Forward Confirmation');
		} catch (ex) {
				alert('error opening forward confirm err::' + ex.message);
				throw (ex);
		}
	}

	/**
	 * mark this resutl reviewed
	 */
	, markReviewed: function(e) {
		this.status('Reviewed', 'set_reviewed');
	}
						// if (this._currentTestId) {var tds = $(this._currentTestId).getElementsByTagName('td')for (var i = 0; i < tds.length; i++ ) {if ('status' === tds[i].getAttribute('headers')) {tds[i].innerHTML = 'Reviewed' ;	}}new Ajax.Request('spring/results_new', {parameters: {kind: 'reviewed', testid: this._currentTestId }	}) ;}return false;}
	/**
	 * mark this result saved
	 */
	, save: function(e) {
		this.status('Saved', 'set_saved');
	}
	
	/**
	 * move this result to new
	 */
	, moveToNew: function(e) {
		this.status('New', 'set_new');
	}
	
	/**
	 * mark this result as signed
	 */
	, sign: function(e) {
		this.status('Signed', 'set_signed');
		if ( $('undoRemoveAction').getAttribute('disabled')) {
			$('undoRemoveAction').removeAttribute('disabled');
		}
	}
	
	/**
	 * unsign this result by making it reviewed
	 */
	, unsign: function(e) {
		this.markReviewed(e);
		if (! $('undoRemoveAction').getAttribute('disabled')) {
			$('undoRemoveAction').setAttribute('disabled', 'disabled');
		}
	}

	/**
	 * refresh the view
	 */
	, refresh: function(e) {
		// var currentTestId = this._currentTestId;
		if ( $('newResultsTabNew').hasClassName('activeTab') ) {
			this.activateNewTab(null);
		} else {
			this.activateSavedTab(null);
		}
	}
	
	/**
	 * internal action reuqired to update the status of this result
	 */
	, status: function(p_newStatus, p_theKind) {
		if (this._tableCtl && (null != this._tableCtl.getLastSelected()) ) {
			var testTr = this._tableCtl.getLastSelected();
			var tds = testTr.getElementsByTagName('td')
			for (var i = 0; i < tds.length; i++ ) {
				if ('status' === tds[i].getAttribute('headers')) {
					tds[i].innerHTML = p_newStatus ;
					break;
				}
			}
			new Ajax.Request('spring/results_new', { 
				parameters: {kind: p_theKind
					, testid: testTr.id }
			}) ;
		}
		return false;
	}
	
	
	/**
	 * onclick event handler for the tabs.  first the display updates the
	 * colors of the tabs, then it sets the selected result to nothing --
	 * we are starting with a new list, and then it sets up the event listeners 
	 * to the currently selected tab.
	 * @public
	 * @param e the event as generated by the browser
	 * @param p_tabId the id of the selected tab
	 * @param p_patientId not used placeholder for future reference
	 * @returns false to stop bubble 
	 * @type boolean
	 * @calls rowSelected.clean, this.notify
	 */
	, activateNewTab: function(e) {
		try {
			this._tableCtl.cancelLast();
			this._detail('');
			this._new();
			this._curTab = 'NEW';
			return false;
		} catch(ex) {
			alert('newResults.activateTab err:: ' + ex.message);
			throw (ex);
		}
	}
	
	/**
	 * onclick event handler for the tabs.  first the display updates the
	 * colors of the tabs, then it sets the selected result to nothing --
	 * we are starting with a new list, and then it sets up the event listeners 
	 * to the currently selected tab.
	 * @public
	 * @param e the event as generated by the browser
	 * @param p_tabId the id of the selected tab
	 * @param p_patientId not used placeholder for future reference
	 * @returns false to stop bubble 
	 * @type boolean
	 * @calls rowSelected.clean, this.notify
	 */
	, activateSavedTab: function(e) {
		try {
			this._tableCtl.cancelLast();
			this._detail('');
			this._saved();
			this._curTab = 'SAVED';
			return false;
		} catch(ex) {
			alert('newResults.activateTab err:: ' + ex.message);
			throw (ex);
		}
	}

	
	/**
	 * fetch a lab result into the resultsDetailContainer. uses Guard pattern
	 * to ensure a lab results id
	 * @param e the event as created by browser
	 * @param p_labId the id of the test
	 * @return false to stop bubble
	 * @public
	 * @calledby inline onclick event handler in the list of a patients results
	 * @calls rowSelected.newSelected this.notify
	 */
	, getDetails: function(e, p_testId){
		try { 
			if (! p_testId){
				alert('error cannot determine test id ');
				return (false);
			}
//			this._currentTestId = p_testId;
			this._tableCtl.selected(p_testId);
			//rowSelected.newSelected(p_testId);
			this._detail(p_testId);
			return (false);
		} catch (ex) {
			alert('newResults getLab ::' + ex.message);
			throw (ex);
		}
	}
	
	

	//////////////////////////////////////
	
	/**
	 * private interface to react to a click for report details
	 * if there is no test id, clear the details area, else
	 * get the details from he server passing a hook into the
	 * detail rendering
	 * @returns false to stop bubble
	 * @type boolean
	 * @calls this._setDetailsCntnr 
	 * @calledBy this.getDetails 
	 */
	, _detail: function (p_testId){
		try {
			if (! p_testId || 1 > p_testId.length ) { 
				this._setDetailsCntnr('');
			} else { // was it the test or the tab
				this._enableButtons();
				this._getServerData('spring/results_new?kind=get_details&testid=' 
						+ p_testId, this._setDetailsCntnr);
			}
			return (false);
		} catch (ex) {
			alert('newResultsUpdater.zDetail err:: '+ ex.message);
			throw (ex);
		}
	}
	
	/**
	 * isolate the functionality to turn off the action buttons.
	 * any inputs of type img must have their images swapped.
	 * if the input is of type button then it is disabled
	 * @calledby doTab
	 * @type void
	 * @private
	 */
	, _doDisableButtons: function() {
		$('saveAction').setAttribute('src', 'WebContent/public/media/images/actions/ActionIcon_Save_UA_18x18.gif' )
		var myButtons = this._disableButtons;
		for (var i = 0; i < myButtons.length; i++ ) {
			if (! $(myButtons[i]).getAttribute('disabled')) {
				$(myButtons[i]).setAttribute('disabled', 'disabled');
			}
		}
	}
	
	/**
	 * un-disable anything is the array that is passed in
	 * @calledby _enableNewButtons _enableSavedButtons
	 * @private
	 */
	, _doEnableButtons: function(p_buttons) {
		for (var i = 0; i < p_buttons.length; i++ ) {
			if ( $(p_buttons[i]).getAttribute('disabled')) {
				$(p_buttons[i]).removeAttribute('disabled');
			}
		}
	}

	/**
	 * turn on the new buttons
	 * @calledby _enableButtons
	 */
 	, _enableNewButtons: function() {
		$('saveAction').setAttribute('src'
				, 'WebContent/public/media/images/actions/ActionIcon_Save_Link_18x18.gif' );
		this._doEnableButtons(this._newButtons);
	}

	/**
	 * turn on the save buttons
	 * @calledby _enableButtons
	 */
	, _enableSavedButtons: function() {
		this._doEnableButtons(this._savedButtons);
	}

	/**
	 * enable buttons because a report detail has been accessed
	 * @calledby getDetails
	 * @calls this._enableNewButtons this._enableSavedButtons
	 */
	, _enableButtons: function () {
		// var curTab = $(this.CONTAINER).getAttribute(this.CUR_TAB);
		if ('NEW' == this._curTab) {
			this._enableNewButtons();
		} else if ('SAVED' == this._curTab) {
			this._enableSavedButtons();
		}
	}
	
	/**
	 * wrapper for the ajax calls which takes the url to target complete with
	 * query string and calls GET.  the second parameter is a function which 
	 * is treated as a hook and called with the result sent by the server
	 * @calls p_containerSetter
	 * @calledby _new _saved and _details
	 * @private
	 * 
	 */
	, _getServerData: function(p_targetUrl, p_containerSetter) {
		try { 
			new Ajax.Request(p_targetUrl,  { method: 'get' , 
				onSuccess: function(xResp) {
					p_containerSetter(xResp.responseText);
				}, onFailure: function(xResp) {
					p_containerSetter('data unavailable');//xResp.responseText);
				}, onexception: function(theReq, ex) {
//					alert(ex.message);	
				}
			});
			return (false);
		} catch (ex) {
//			alert('newResults getLab ::' + ex.message);
		}
	}
	, _clearResults: function() {
		$('nbrResults').innerHTML = 'Fetching';
		$('resultsContainer').innerHTML = '';	
	}
	/**
	 * the new tab has been clicked, so turn off any buttons
	 * because when a tab is click there are no details
	 * and the buttons are only for the details.
	 * next, we change the css of the new tab and the saved tab
	 * and get the list of new results off the server
	 * @called by activatenewTab
	 * @calls this._getServerData this._doDisableButtons
	 */
	, _new: function (){
		try {
			this._doDisableButtons();
			$('newResultsTabSaved').removeClassName('activeTab');
			$('newResultsTabSaved').addClassName('inactiveTab');
		
			$('newResultsTabNew').removeClassName('inactiveTab');
			$('newResultsTabNew').addClassName('activeTab');
			this._clearResults();
			var patientId = $('current_patient').getAttribute('patient_id');
			this._getServerData('spring/results_new?kind=get_new&patientid=' 
					+ patientId, this._setResultsCntnr);
			return (false);
		} catch (ex) {
			alert('newResultsUpdater.zNew err:: '+ ex.message);
			throw (ex);
		}
	}

	/**
	 * the saved tab has been clicked, so turn off any buttons
	 * because when a tab is click there are no details
	 * and the buttons are only for the details.
	 * next, we change the css of the new tab and the saved tab
	 * and get the list of saved results off the server
	 * @called by activateSavedTab
	 * @calls this._getServerData this._doDisableButtons
	 */
	, _saved: function (){
		try {
			this._doDisableButtons();
			$('newResultsTabNew').removeClassName('activeTab');
			$('newResultsTabNew').addClassName('inactiveTab');
			
			$('newResultsTabSaved').removeClassName('inactiveTab');
			$('newResultsTabSaved').addClassName('activeTab');
			this._clearResults();

			var patientId = $('current_patient').getAttribute('patient_id');
			this._getServerData('spring/results_new?kind=get_saved&patientid=' 
					+ patientId, this._setResultsCntnr);
			return (false);
		} catch (ex) {
			alert('newResultsUpdater._saved err:: '+ ex.message);
			throw (ex);
		}
	}
	
	/**
	 * hook function to find which div to put the innerhtml
	 * note that ajax calls happen asynchonously
	 * @called by getServerData
	 */
	, _setDetailsCntnr: function (p_innerHtml) {
		try {
			$('resultsDetailContainer').innerHTML = p_innerHtml;
		} catch (ex) {
			alert('error setting datails innerhtml ::' + ex.message);
			throw (ex);
		}
	}
	
	/**
	 * hook function to find which div to put the innerhtml
	 * note that ajax calls happen asynchonously updates the number of rows
	 * @called by getServerData
	 */
	, _setResultsCntnr: function (p_innerHtml) {
		try {
			$('nbrResults').innerHTML =countTbodyRows(p_innerHtml);
			$('resultsContainer').innerHTML = p_innerHtml;
		} catch (ex) {
			alert('error setting results innerhtml ::' + ex.message);
			throw (ex);
		}
	}


	/**
	 * 
	 * critical setup referenced from the menuing system to set up the environment
	 * here we bind the listeners and set the active tab
	 * 
	 * called by static initializer
	 * calls initapptlisteners
	 */
	, initContent: function() {
		try {
			newResultsAction.tableCtl = new TableCtl();
			this._tableCtl = new TableCtl();
			this.activateNewTab(null);
		} catch (ex) {
			alert('init newResults err:: ' + ex.message);	
			throw(ex);
		}
	}

	
	/**
	 * encapsulate the action for the popup functioning of the legend
	 * @public
	 * @calledby front end markup onclick event handler
	 */
	, openLegend: function(e) {
		doGet('spring/results_new?kind=legend', this._openLegend );
		return (false);
	}
	, _openLegend: function (p_serverData) {
		try {
			popup.fill(p_serverData, 'New Results Legend' );
		} catch (ex) {
			alert('error opening legend popup::' + ex.message);
			throw (ex);
		}
	}
	, forwardConfirm: function(e){
		newResultsAction.forwardConfirm(e);
	}
};


/**
 * this is an encapsulation of the functionality of the New Results
 * action buttons
 */
var newResultsAction = {
		
		/**
		 * this is the handle to the table controller which will keep
		 * track of the currently selected row.  note that insance or
		 * the table controller is the life time of the table
		 * if the table is replaced so too must the controlled
		 */
	tableCtl : null
		
	/**
	 * flag to see if we are trying to forward the result but
	 * no provider has been selected so we must interrupt the 
	 * forward and do the provider search and then return to
	 * the forwarding process
	 * @private
	 */
	, _forwardInterupt : null

	/**
	 * update the table controller that a row has been selected
	 */
	, tableClick: function(e, p_idRow ){
		this.tableCtl.selected(p_idRow );
		return false;
	}

	/**
	 * if there is no selected provider, pop the provider search, otherwise
	 * tell the server to farward the result
	 */
	, forwardConfirm: function(e){
		var providerNcid = $('sel_prov').value;
		if (null == providerNcid || 1 > providerNcid.length) {
			this._forwardInterupt = true;
			return this.popProviderSearch(e);
		} else {
			doGet('spring/results_new?kind=forwardConfirm&providerNcid=' 
					+ providerNcid, this._openForwardConf );
			return (false);
		}
	} 
	
	/**
	 * hook method to fill the popup with the Forward form
	 */
	, _openForwardConf: function(p_serverData) {
		try {
			popup.fill(p_serverData, 'Forward');
		} catch (ex) {
			alert('error opening forward confirm err::' + ex.message);
			throw (ex);
		}
	}
	
	/**
	 * if enter key, submit form
	 */
	, popupEnterPressed: function (e) {
		try {
			if (e) {
				var prototyped = Event.extend(e);
				if (Event.KEY_RETURN === prototyped.keyCode) {
					prototyped.stop();
					if (Browser.isIE) {
						var muEvt = document.createEventObject();
						muEvt.relatedTarget = null;
						muEvt.cancelBubble = true;
						muEvt.returnValue = false;
						$('btnOk').fireEvent('onmouseup', muEvt);
						Event.stop(muEvt);
					} else {
						var muEvt = document.createEvent("MouseEvents");
						muEvt.initEvent("mouseup", true, true);
						$('btnOk').dispatchEvent(muEvt);
					}
					return false;
				}
			}
		} catch (ex) {
			alert('popupEnterPressed err::' + ex.message);
		}
	} 
	
	/**
	 * handler for when a row is double clicked on the provider form
	 */
	, dblClick: function(e, p_providerNcid ){
		$('sel_prov').value = p_providerNcid;
		popup.close();
		if ( true == this._forwardInterupt) {
			this._forwardInterupt = null;
			this.forwardConfirm(e);
		} 
		return (false);
	}  

	/**
	 * pop the windo for the provider search and pass in the hook method (in line ie
	 * lamda function later
	 */
	, popProviderSearch: function(e) {
		doGet('spring/results_new?kind=provider', this._openProvider );
		return (false);
	}

	/**
	 * get the valeu for the options tag in the providee facility list
	 */
	, providerFacClin: function(e, p_facNcid) {
		var mySel = $('provider_facility');
		if (-1 < mySel.selectedIndex) {
			var facNcid = mySel.options[mySel.selectedIndex].value;
			doGet('spring/results_new?kind=providerClinics&facNcid=' + facNcid, this._clinicsAjax );
		}
		return (false);
	}

	/**
	 * do the provider find by getting the stem last name
	 * entered or alert the error
	 */
	, providerFind: function(e) {
		if (3 > $('provider_name').value.length){
			alert('Please enter 3 or more characters for provider name');
			return false;
		}
		//get form data, send to server, get resp
		doGet('spring/results_new?kind=providerFind&' 
				+ FormCtl.buildQueryStr($('newResultsProviderSearchForm'))
				, this._providerFindAjax );
	}
	
	/**
	 * here the provider search has completed so we close the popup and if the 
	 * forward action is interrupted we return to it.
	 */
	, providerSel: function(e) {
		var lastSelected = this.tableCtl.getLastSelected();
		if (null != lastSelected) {
			$('sel_prov').value = lastSelected.id;
		}
		popup.close();
		if ( true == this._forwardInterupt) {
			this._forwardInterupt = null;
			this.forwardConfirm(e);
		} 
		return (false);
	}
	
	/**
	 * the clear button has been pressed so we reset the state
	 */
	, providerClear: function(e) {
		this.tableCtl.cancelLast();
		$('pop_search_container').innerHTML = '';
		return (false);
	}
	
	/**
	 * the cancel button has been pressed in the provider search
	 * so if we interrrupted forward we must end the forward as well
	 */
	, providerCancel: function(e) {
		popup.close();
		if ( true == this._forwardInterupt) {
			this._forwardInterupt = null;
		} 
		return (false);
	}
	
	/**
	 * this is the callback hook for the provider search.  note
	 * re must double-set the inner html so msie can register the
	 * event handlers
	 */
	, _providerFindAjax: function (p_serverData) {
		try {
			$('pop_search_container').innerHTML = p_serverData;
			$('pop_search_container').innerHTML = $('pop_search_container').innerHTML;
		} catch (ex) {
			alert('error in ajax update of provider clinic::' 
					+ ex.message
					+ '|' + p_serverData
					+ '|' + $('providerSearchTable').innerHTML );
			throw (ex);
		}
	}
	
	/**
	 * this is a fix for the msie dynamic replacement of the select options
	 */
	, _clinicsAjax: function (p_serverData) {
		try {
			$('clinicWrap4ie').innerHTML = p_serverData;
		} catch (ex) {
			alert('error in ajax update of provider clinic::' + ex.message);
			throw (ex);
		}
	}

	/**
	 * pop the provider search window
	 */
	, _openProvider: function (p_serverData) {
		try {
			popup.fill(p_serverData, 'Provider Search' );
		} catch (ex) {
			alert('error opening provider search popup::' + ex.message);
			throw (ex);
		}
	}
	

};

